#include <stdio.h>

int main()
{
	int bit_H;
	int bit_M;
	int bit_L;
	int Result;
	int tag = 0;

	for(bit_H = 1; bit_H < 5; bit_H++) {
		for(bit_M = 1; bit_M < 5; bit_M++) {
			for(bit_L = 1; bit_L < 5; bit_L++) {

				if((bit_H != bit_M) && (bit_M != bit_L) && (bit_H != bit_L)) {
                    
					Result = (bit_H * 100) + (bit_M * 10) + bit_L;
					printf("%d      ", Result);
					tag++;
                
				if((tag) % 4 == 0) {
					printf("\n");
				}

				}
			}
		}
	}
    
    return 0;
}

/*
    总结：
	    此处，我想的是第二个数与第一个数不一样，第三个数和前两个数不一样，
		那就在使用第二个数前，如何避开第一个数，还要变化，第三个数就更复杂了。

        但是，从题目要求的最终结果来看，需要的是相互组合，且无重复数字的数据。
		for循环可以达到排列的作用，但是有重复数字的结果，而无重复数字，就让
		i、j、k互不相同就有可以了。

        所以，像这样数字排列组合的题目，可以用for循环先得到所有的排列结果，
		之后再在里面筛选符合要求的，这样简单易看懂，又能完成要求。

  
	    心得：
		得到题目，先看清楚题目，充分了解题目的要求，再对要求的任务进行大致规划，
		得到最优大方向，再开始研究具体行动细节。

		最忌讳的行为：随便看下题目，抓住脑海中的想到的第一种方法就死钻细节
*/